Многопоточность и асинхронность это разные вещи.

Многопоточность ускоряет работу определенного алгоритма. Когда асинхронность, позволяет процессам не простаивать и распределять ресурсы на другие алгоритмы, функции и тд.

При разборе алгоритма и способа его ускорения часто играют следующие вещи.
Ввод-вывод - использование сокета, подключение к базе данных, ожидание погрузки из виртуальной памяти.
Процессор - числовые вычисления, обработка регулярных выражений, уборка мусора и тд.
В конкретном алгоритме, часто, всего одна какая-то определенная проблема, решив её, можно ускорить алгоритм

Количество возможных вариантов потоков - это зависит на сколько строк байт кода разделится наш метод, В целом формула такая (N*T)! / N*T. Где N - количество строк байт кода, T - количество потоков. 

На данный момент IT далеко ушло в плане многопоточносии, там используется много Enterprice паттернов, гениальные и оптимизированных схем, даже используются специальные процессорные инструкции такие как CAS, похожие название одних приемов используются в разных языках по разному, например фьючерсы в джаве и обещания в C#

 Избегайте зависимости между методами в многопоточном коде, особенно на клиентских приложениях, в клиентском приложении достаточно где-то забыть об одной блокировке и все приложение упадет


