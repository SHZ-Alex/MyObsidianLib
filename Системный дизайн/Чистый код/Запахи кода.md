Тут будет большое количество советов, по тому, как писать хороший и поддерживаемый код, в чистом коде используется понятие "Запах кода", как оценку качества написанного

***С1 - Неуместная информация***
В комментариях не уместно хранить информацию о истории изменения кода(старая практика), мета данные, все эти моменты должны быть отражены в git или документации проекта

***С2 - Устаревшие комментарии***
Комментарий, который потерял актуальность, считается устаревшим, если вы увидели такой комментарий, удалите или перепишите его, часто такое поддерживать сложно, поэтому лучше пишите документацию

***С3 - Избыточные комментарии***
Это порой очень очевидные комментарии, которые просто загромождают код, если ваш комментарий описывает код, который вы написали, скорее вы плохо написали код, комментарии должны описывать то, что код не касается

***С4 - Плохо написанные комментарии***
Если вы решили написать комментарий, отнеситесь к этому очень серьезно и не используйте кодо-генерацию, вчитывайтесь в каждое слово и два раза подумайте, стоит ли оно того

***С5- Закоментированный код***
Часто кому-то жалко удалить старый код и он считает, что эта секция может принести в будущем какую-то пользу, это очень большое заблуждение, часто если просто раскоментировать секцию, она уже не сможет встать в код, потому как название переменных или функций изменилось и теперь нужно его адаптировать, если вы помните, что такой код был, лучше потом вернуться к тому коммиту, где был этот код и переписать

***Е1 - построение состоит из нескольких этапов***
Запуск проекта должен быть максимально простой задачей, без дополнительного поиска отдельных файлов, эта сложность зависит от ЯП и IDE

***Е2 - Тестирование состоит из нескольких этапов***
Все модульные тесты должны выполняться одной кнопкой в IDE, в худшем случае, если это команда командной строки, тесты должно хотеться запускать и запускать просто

***F1 - Слишком много аргументов***
В функции должно быть не больше 2-3 аргументов, если там уже 4 аргумента, то лучше завернуть это в DTO, если это простая бизнес логика, то можно использовать аргументы, если это трансфер между слоями приложения, то DTO

***F2 - Выходные аргументы***
Выходные аргументы противоествественные для программирования. Если Ваша функция должна изменять состояние объекта, то пусть изменяет, для объекта, которого вызывалось

***F3 - Флаги в аругментах***
Если флаги указывают, что функция должна выполняет более одной логической операции, такое нужно убирать.

***F4 - Мертвые функции***
Если метод не используется, смело удаляйте, он только заграмождает и путает людей. Если кто-то помнит, что такая функция была и для чего-то использовалась, используйте git.

***G1 - Несколько языков в одном файле***
Бывает такое, что в одном классе есть и XML, HTML, C# код, такое лучше разделять, чтобы не путать читателей и так будет поддерживать код проще.

***G2 - очевидное поведение не реализовано***
Функция должна отдавать то, что от неё ожидает разработчик, а иначе на знакомства с кодом уйдет большое количество времени, знакомиться с этим фреймворком не захочется, как и с этим автором.

***G3 - Некорректное граничное поведение***
Код должен работать верно всегда, часто мы полагаемся на свою интуицию и не тестируем этим моменты, всегда находите эти граничные моменты и пишите на него тесты

***G4 - отключение средства безопасности***
Однажды директор ЧАЭС, отключили все механизмы безопасности, потому что они мешали эксперименту, в итоге случилось то, что произошло, не пренебригайте и не отключайте требования безопасности IDE и компилятором, часто потом это приводит к часам дебага.

***G5 - дублирование***
Про дублирование посвящено много текста, он и в принципах [[SOLID]], и аббревиатур [[DRY]], это второе правило по требованиям к рабочей архитектуре. Часто каждое повторение это упущение для абстракции. Часто дублирование встречается в if/else, switch/case или сложнее в больших алгоритмах логики. во всех ситуациях дублирование можно убирать.

***G6 - Код на неверном уровне абстракции***
В каждой архитектуре важную роль играют абстракции, именно из-за них удается писать чистую и масштабируемую архитектуру, размещать код на разных уровнях абстракции это сложное дело и надо это видеть правильно

***G7 - Базовые классы, зависят от производных***
Верхнеуровневая логика должна зависеть от абстракций, бывают исключения, например в [[Конечный автомат]], но чаще всего должны быть абстракции, базовые классы не должны ничего знать о своих производных классах.

***G8 - Слишком много информации***
Каждый сервис должен выполнять небольшой и четкий набор действий, не нужно в один интерфейс пихать все возможные методы, каждый публичный метод интерфейса должен отвечать [[S]] принципу.

***G9 - мертвый код***
Часто в бывают кейсы if, которые уже не актуальны и метод туда не заходит, или блок catch, который уже не падает в ошибки, или отдельные методы switch/case, чем дольше такой код не используется, тем сильнее от него плохой запах, не нужно оставлять не рабочие и не актульные блоки кода.

***G10 - Вертикальное разделение***
Переменные и функции должны быть рядом с местом, где они используются, приватные методы идти ниже, чем публичные методы, константы и инжекты в самом верху класса, код должен читаться сверху вниз

***G11 - Непоследовательность***
Если какая-то функция имеет определенное действие, то похожие функции должен иметь похожее действие, пишите код в одном стиле и операции в них прописывайте так же.

***G12 - Баласт***
От неиспользованных конструкторов или функций, которые нигде не вызываются портят картину кода, это баласт в коде, удаляйте этот код, а если нужно будет вспомнить эту функцию, то она сохранится в гите.

***G13 - Искусственные привязки***
Искусственной привязкой называется то, что связано бизнес логикой, которая подразумевает зависимость этого класса, поля, перечисления и тд. Не используйте одну Dto(в которой поля одинаковые) в разных местах, просто потому что удобно, часто это просто лень, чтобы записать грамотно. То, что должно зависеть, должно зависеть.

***G14 - функциональная зависимость***
Для методов класса, должны быть важны методы и переменные этого класса, а не какого-то другого, от таких функциональных зависимостей следует избавляться, потому что она предоставляет доступ к внутренностям другого класса, хотя иногда без этого никуда.

***G15 - аргументы селекторы***
Плохой тон передавать в метод false/tru или какие-то другими возможные ветвления, от которых зависит функция, часто это просто лень, разбить один метод на несколько по меньше, где каждый будет отвечать за свое.

***G16 - Непонятные намерения***
Часто программисты делают очень компактную запись, но очень слабо понятную, слишком длинные выражения, венгерские записи и магические константы позволяют хуже разбираться в коде, не делайте так, оставляйте приоритет поддерживаемости, чем внешнему виду

***G17 - Неверное размещение***
Один из самых сложных решений, это в какой класс поместить тот или иной метод или константу, например число PI, лучше поместить в Math, или Trigonometry, или в Circle. Посоветуйтесь с товарищами, размещайте переменные там, где их ожидают увидеть разработчики.

***G18 -неуместные статические методы***
Такие методы как Math.Max(a, b) выглядят уместными, эта функция почти никогда не изменится, функция берет только данные от двух аргументов, а не какого-то пользователя, с другой стороны расчет зарплаты в час не должен быть статическим, потому как его поведение может быть полиморфным, лучше всегда использовать не статические методы, если есть сомнения, то лучше сделать не статической

***G19 - Используйте пояснительные переменные***
Используйте промежуточные переменные, чтобы повысить удобочитаемость кода, чтобы лишний раз не смотреть, что возвращает та или иная функция, это экономит время и это хорошая практика

***G20 -имена функций должны описывать выполняемую операцию***
Например плохой пример варианта DateTine newDate = date.Add(5), что делает эта функция? Добавляет 5 дней у существующему экземпляру? Или возвращает новый? Можно придумать названия лучше dayLater или addDaysTo
 
***G21 -понимание алгоритма***
Очень часто не хорошо подумав над алгоритмом, мы пишем его и добавляем множество if else там, где это не нужно, порой нужно остановиться и хорошо расписать алгоритм на бумаге, а после реализовывать, чтобы он прошел все тесты, которые мы написали для него, декомпозируйте алгоритмы

***G22 -Преобразование логических зависимостей в физическое***
Если модуль зависит логически и бизнусово, то и в коде он должен зависеть физически, модули должны иметь одну и ту же реализацию, если что-то должно зависеть, то оно должно зависеть.

***G23 - используйте полиморфизм вместо if/else или switch/case***
Если в модуль будут дополняться новые функции, а не новые типы, то switch уместен, switch это метод грубой силы, часто это можно заменить полиморфизмом.

***G24 - соблюдайте стандартные конвенции***
Соблюдайте код стайл своей команды, например название переменных, методов, фигурные скобки и другое, это важно, для читабельности и восприятия кода, в идеале, код стайл должны понимать из самого кода

***G24 - соблюдайте стандартные конвенции***
***G24 - соблюдайте стандартные конвенции***
***G24 - соблюдайте стандартные конвенции***
***G24 - соблюдайте стандартные конвенции***
***G24 - соблюдайте стандартные конвенции***
***G24 - соблюдайте стандартные конвенции***
***G24 - соблюдайте стандартные конвенции***
***G24 - соблюдайте стандартные конвенции***
***G24 - соблюдайте стандартные конвенции***
***G24 - соблюдайте стандартные конвенции***
***G24 - соблюдайте стандартные конвенции***
***G24 - соблюдайте стандартные конвенции***

***G24 - соблюдайте стандартные конвенции***
***G24 - соблюдайте стандартные конвенции***
