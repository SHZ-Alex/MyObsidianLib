Хеш-карту можно сделать как последовательную пары "ключ-значение" и если их не сортировать, они будут идти в том порядке, в каком были записаны. Этот порядок ни на что не влияет.

Мы добавляем сюда новое требование. Последовательность пар "ключ - значение" должно быть отсортирована по ключу. На первый взгляд, это требование помешает последовательной записи, но это решим позже.

Назовем такой формат отсортированной строковой таблицей(sorted strinng table), сокращенно SS table. Мы потребуем также, чтобы ключ встречался лишь один раз, алгоритм уплотнения гарантирует это. у SS-таблиц есть несколько больших преимуществ перед журнальными хеш-индексами:
1. Объединение сегментов выполняется просто и эффективно, даже если размер больше объема оперативной памяти. Этот алгоритм близок к сортировке слиянием. Начинаем с одновременного чтения входных файлов, просматриваем первый ключ в каждом из файлов, копируем самый нижний ключ в выходной файл и повторяем эти действия. В результате получаем новый файл  сегмента отсортированный по ключу.  Но что если один и тот же ключ встретится в нескольких сегментах? В этом случае берем значение более нового сегмента, старый отбрасываем.
2. Для того, чтобы найти ключ, мы можем не хранить полную хеш-карту, если у нас будет похожий ключ, например handiwork, нам неизвестно его индекс в файле, но нам известно handbag и handsome, благодаря сортировке то, что handiwork должен находиться между ними. Как следствие, можно просто пройтись по списку между ними и найти нужный ключ. Нам все еще нужны некоторые индексы в оперативной памяти, чтобы узнавать это смещение. На каждый наш сегмент можно хранить по несколько килобайт в кеше, это сильно сэкономит место.
3. Поскольку для поиска "ключ-значение", все равно потребуется просмотреть несколько таких диапозонов, поэтому вполне можно сгрупировать эти записи в блок и сжать его перед записью на диск. Каждая запись разряженного индекса, будет указывать на начало сжатого блока. Это сэкономит пространство на диске и снижет запросы на поток ввода/вывода.