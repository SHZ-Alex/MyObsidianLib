Запросы ищут в индексе ключ, а значение может быть любым, это может быть искомой строкой, ссылка на строку хранящуюся в другом месте. Если индекс хранит строки, то его называют неупорядоченным файлом (heap file), и данные там хранятся соответственно, в неупорядоченном ввиде. Неупорядоченные файлы используются часто, они помогают избежать дублирование данных в случае нескольких вторичных индексов, все индексы лишь ссылаются на местоположение в неупорядченном файле, а фактические данные хранятся в одном месте.

При обновлении значения в индексе с неупорядоченными файлами, может оказаться продуктивным, при условии, что новое значение меньшее старого, если наоборот, то ту сложнее и скорее придется разместить новое значение в другом месте и изменить все индексы так, чтобы они указывали на новую позицию в неупорядоченном файле или разместить указать по старому адресу указатель, для переадресации.

В некоторых случаях лишний переход от индекса к неупорядоченному файлу затратная вещь, поэтому желательно хранить проиндексированную стоку непосредственно в индексе. Такой вариант носит название кластеризированного индекса. Этот вариант уже реализован в большинстве реляционных БД, первичный ключ кластеризированный индекс, а вторичные на него ссылаются, обычно на таблицу один кластеризированный индекс.

Компромисс между кластеризованным(хранит все ключи в индексе) индексом и некластеризованным(хранит только ссылки на данные) называется охватывающим индексом или индекса с включенными столбцами. При этом в индексе хранится только часть столбцов таблицы. Благодаря такому индексу на некоторые охватывающие запросы можно использовать только один индекс.

Как и при любом ввиде дублирования данных, кластеризованный и охватывающй индексы могут ускорить чтение, но потребуют доп. места на диске и увеличат срок записи новых данных. Базам данных так же потребуются доп. усилия для обеспечения транзакционности, поскольку приложения не должны сталкиваться с несогласованностью из-за дублирования.